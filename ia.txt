# MeshDrive - Documentation pour IA

## ğŸ“‹ Vue d'ensemble du projet

MeshDrive est un systÃ¨me de stockage cloud sÃ©curisÃ© avec chiffrement cÃ´tÃ© client. Il permet aux utilisateurs de stocker leurs fichiers de maniÃ¨re chiffrÃ©e sur un serveur, avec isolation complÃ¨te des donnÃ©es par utilisateur.

### Objectif principal
CrÃ©er une alternative open-source Ã  Google Drive/Dropbox avec :
- Chiffrement end-to-end (E2EE)
- Multi-utilisateurs avec isolation complÃ¨te des donnÃ©es
- Interface web moderne
- API REST pour intÃ©gration

---

## ğŸ—ï¸ Architecture du projet

### Structure des dossiers

```
MeshDrive/
â”œâ”€â”€ api/                    # API FastAPI (backend)
â”‚   â”œâ”€â”€ crypto_api.py      # Endpoints principaux (encrypt, decrypt, files, folders)
â”‚   â””â”€â”€ run_api.py         # Script de lancement
â”‚
â”œâ”€â”€ core/                   # Modules core (authentification, base de donnÃ©es)
â”‚   â”œâ”€â”€ database.py        # ModÃ¨les SQLAlchemy (User, etc.)
â”‚   â”œâ”€â”€ auth.py            # Authentification JWT
â”‚   â”œâ”€â”€ auth_routes.py     # Routes d'authentification (/auth/login, /auth/register)
â”‚   â””â”€â”€ utils.py           # Utilitaires (get_crypto_system_for_user)
â”‚
â”œâ”€â”€ cryptolib/              # BibliothÃ¨que de chiffrement
â”‚   â”œâ”€â”€ __init__.py        # Point d'entrÃ©e (CryptoSystem)
â”‚   â”œâ”€â”€ encryptor.py       # Chiffrement de fichiers
â”‚   â”œâ”€â”€ decryptor.py       # DÃ©chiffrement de fichiers
â”‚   â”œâ”€â”€ chunk_manager.py   # Gestion des chunks (dÃ©coupage des fichiers)
â”‚   â”œâ”€â”€ metadata_manager.py # Gestion des mÃ©tadonnÃ©es (clÃ©s, infos fichiers)
â”‚   â”œâ”€â”€ folder_manager.py  # Gestion des dossiers
â”‚   â”œâ”€â”€ models.py          # ModÃ¨les Pydantic (FileInfo, FolderInfo, etc.)
â”‚   â””â”€â”€ config.py          # Configuration (chemins, tailles de chunks)
â”‚
â”œâ”€â”€ web/                   # Interface web (frontend)
â”‚   â”œâ”€â”€ dashboard.html      # Page principale (dashboard)
â”‚   â”œâ”€â”€ drive.html          # Interface du drive (upload, navigation)
â”‚   â”œâ”€â”€ login.html          # Page de connexion/inscription
â”‚   â””â”€â”€ js/                 # Scripts JavaScript
â”‚       â”œâ”€â”€ auth.js         # Gestion de l'authentification
â”‚       â”œâ”€â”€ api.js          # Appels API
â”‚       â”œâ”€â”€ files.js         # Gestion des fichiers
â”‚       â”œâ”€â”€ folders.js       # Gestion des dossiers
â”‚       â”œâ”€â”€ dragdrop.js      # Upload drag & drop
â”‚       â”œâ”€â”€ navigation.js    # Navigation dans les dossiers
â”‚       â”œâ”€â”€ state.js         # Ã‰tat de l'application
â”‚       â”œâ”€â”€ ui.js            # Interface utilisateur
â”‚       â””â”€â”€ utils.js        # Utilitaires frontend
â”‚
â””â”€â”€ data/                  # DonnÃ©es stockÃ©es (chunks, clÃ©s, DB)
    â”œâ”€â”€ chunks/            # Fichiers chiffrÃ©s (par utilisateur)
    â”œâ”€â”€ keys/              # ClÃ©s de chiffrement (par utilisateur)
    â””â”€â”€ meshdrive.db       # Base de donnÃ©es SQLite
```

---

## ğŸ› ï¸ Technologies utilisÃ©es

### Backend
- **FastAPI** : Framework web async pour l'API REST
- **SQLAlchemy** : ORM pour la gestion de la base de donnÃ©es
- **SQLite** : Base de donnÃ©es (peut Ãªtre migrÃ©e vers PostgreSQL)
- **JWT (jose)** : Authentification par tokens
- **bcrypt** : Hashage des mots de passe
- **Pydantic** : Validation des donnÃ©es et modÃ¨les

### Frontend
- **Vanilla JavaScript** : Pas de framework (pour la simplicitÃ©)
- **Fetch API** : Appels HTTP Ã  l'API
- **HTML5** : Structure des pages
- **CSS** : Styles inline (pourrait Ãªtre externalisÃ©)

### Cryptographie
- **cryptography** (Python) : BibliothÃ¨que de chiffrement
- **AES-256-GCM** : Algorithme de chiffrement symÃ©trique
- **PBKDF2** : DÃ©rivation de clÃ©s depuis les mots de passe
- **Chunks** : DÃ©coupage des fichiers en morceaux pour optimisation

---

## ğŸ” SystÃ¨me de chiffrement

### Principe
1. **Chiffrement cÃ´tÃ© client** : Les fichiers sont chiffrÃ©s avant l'upload
2. **Isolation par utilisateur** : Chaque utilisateur a ses propres chunks et clÃ©s
3. **DÃ©coupage en chunks** : Les fichiers sont divisÃ©s en morceaux de 1MB (configurable)
4. **MÃ©tadonnÃ©es sÃ©parÃ©es** : Les informations sur les fichiers (nom, taille, etc.) sont stockÃ©es sÃ©parÃ©ment

### Structure des donnÃ©es
- **Chunks** : Fichiers `.enc` chiffrÃ©s avec AES-256-GCM
- **ClÃ©s** : Fichiers JSON contenant les mÃ©tadonnÃ©es et infos de chiffrement
- **Organisation** : `data/users/user_{id}/chunks/` et `data/users/user_{id}/keys/`

---

## ğŸ”‘ Authentification et sÃ©curitÃ©

### SystÃ¨me d'authentification
- **JWT tokens** : Tokens d'accÃ¨s avec expiration (30 minutes)
- **OAuth2** : Support OAuth2PasswordBearer pour les requÃªtes standard
- **Headers + FormData** : Double mÃ©thode pour envoyer le token (header Authorization ou FormData)

### ProblÃ¨me rencontrÃ© avec multipart/form-data
**ProblÃ¨me** : Les navigateurs bloquent parfois le header `Authorization` avec `multipart/form-data` lors de l'upload de fichiers.

**Solution** : 
1. Le token est envoyÃ© dans le header `Authorization` (prioritÃ©)
2. Le token est aussi envoyÃ© dans `FormData` comme fallback
3. L'endpoint `/encrypt-folder` extrait le token depuis le header OU depuis FormData

### Isolation des donnÃ©es
- Chaque utilisateur a son propre dossier dans `data/users/user_{id}/`
- Les chunks et clÃ©s sont isolÃ©s par utilisateur
- Le `CryptoSystem` est instanciÃ© avec `user_id` pour garantir l'isolation

---

## ğŸ“¡ API Endpoints

### Authentification
- `POST /auth/register` : CrÃ©ation de compte
- `POST /auth/login` : Connexion (retourne JWT token)
- `GET /auth/me` : Informations utilisateur actuel

### Fichiers
- `POST /encrypt` : Chiffrer et uploader un fichier
- `POST /encrypt-folder` : Chiffrer plusieurs fichiers (multithreading)
- `GET /decrypt/{file_id}` : DÃ©chiffrer et tÃ©lÃ©charger un fichier
- `GET /files` : Lister les fichiers
- `GET /files/{file_id}` : Informations dÃ©taillÃ©es d'un fichier
- `PUT /files/{file_id}/move` : DÃ©placer un fichier
- `DELETE /files/{file_id}` : Supprimer un fichier

### Dossiers
- `POST /folders` : CrÃ©er un dossier
- `GET /folders-all` : Lister tous les dossiers
- `GET /folders/{folder_path}` : Informations d'un dossier
- `GET /folder-contents` : Contenu d'un dossier (fichiers + sous-dossiers)
- `DELETE /folders/{folder_path}` : Supprimer un dossier

### Pages web
- `GET /` : Dashboard principal
- `GET /drive` : Interface du drive
- `GET /login.html` : Page de connexion

---

## ğŸ› ProblÃ¨mes rencontrÃ©s et solutions

### 1. ProblÃ¨me d'organisation du code
**ProblÃ¨me** : Tous les fichiers (database, auth, utils) Ã©taient dans `api/`, crÃ©ant du "spaghetti code".

**Solution** : RÃ©organisation en crÃ©ant `core/` pour les modules core (database, auth, auth_routes, utils) et gardant `api/` uniquement pour l'API FastAPI.

### 2. Token Authorization non reÃ§u avec FormData
**ProblÃ¨me** : Les navigateurs bloquent parfois le header `Authorization` avec `multipart/form-data`, causant des erreurs "Could not validate credentials".

**Solution** : 
- Le token est envoyÃ© dans FormData en plus du header
- L'endpoint `/encrypt-folder` extrait le token depuis FormData via `Form(None)`
- Fallback : header â†’ FormData â†’ erreur

### 3. `Form` non importÃ©
**ProblÃ¨me** : `NameError: name 'Form' is not defined` dans `crypto_api.py`.

**Solution** : Ajout de `Form` dans les imports FastAPI : `from fastapi import ..., Form`

### 4. Consommation du body avec `request.form()`
**ProblÃ¨me** : Appeler `await request.form()` dans `get_current_user` consomme le body, empÃªchant la lecture des fichiers `File(...)`.

**Solution** : Pour les endpoints avec fichiers, l'authentification est faite manuellement dans l'endpoint (pas via `Depends(get_current_active_user)`), en extrayant le token depuis `Form(None)`.

### 5. Isolation des donnÃ©es par utilisateur
**ProblÃ¨me** : Initialement, tous les utilisateurs partageaient les mÃªmes chunks et clÃ©s.

**Solution** : 
- Modification de `CryptoSystem` pour accepter `user_id`
- Chemins dynamiques : `data/users/user_{id}/chunks/` et `data/users/user_{id}/keys/`
- Fonction `get_crypto_system_for_user()` dans `core/utils.py`

---

## ğŸ”„ Flux d'utilisation

### 1. Inscription/Connexion
1. Utilisateur accÃ¨de Ã  `/login.html`
2. CrÃ©ation de compte via `POST /auth/register` ou connexion via `POST /auth/login`
3. RÃ©ception d'un JWT token stockÃ© dans `localStorage`

### 2. Upload de fichier
1. Utilisateur sÃ©lectionne un fichier (drag & drop ou input file)
2. Frontend appelle `POST /encrypt-folder` avec :
   - Fichiers dans `FormData`
   - Token dans header `Authorization` ET dans `FormData`
3. Backend :
   - Extrait le token (header ou FormData)
   - Authentifie l'utilisateur
   - Chiffre le fichier avec `CryptoSystem(user_id=user.id)`
   - Stocke les chunks dans `data/users/user_{id}/chunks/`
   - Stocke les mÃ©tadonnÃ©es dans `data/users/user_{id}/keys/`
4. Retourne les informations du fichier chiffrÃ©

### 3. Navigation et tÃ©lÃ©chargement
1. Utilisateur accÃ¨de Ã  `/drive`
2. Frontend charge les fichiers via `GET /folder-contents?folder_path=/`
3. Pour tÃ©lÃ©charger : `GET /decrypt/{file_id}?download=true`
4. Backend dÃ©chiffre et retourne le fichier

---

## ğŸ“ Ã‰tat actuel du projet

### âœ… FonctionnalitÃ©s implÃ©mentÃ©es
- [x] Chiffrement/dÃ©chiffrement de fichiers
- [x] Authentification JWT
- [x] Isolation des donnÃ©es par utilisateur
- [x] Gestion des dossiers
- [x] Upload multiple avec multithreading
- [x] Interface web complÃ¨te
- [x] API REST complÃ¨te
- [x] Navigation dans les dossiers
- [x] Upload drag & drop

### âš ï¸ ProblÃ¨mes connus
- Le token peut parfois ne pas Ãªtre reÃ§u (selon le navigateur)
- Pas de limite de quota vÃ©rifiÃ©e lors de l'upload
- Pas de partage de fichiers entre utilisateurs
- Pas de recherche de fichiers
- Interface web basique (pas de framework CSS)

### ğŸ”® AmÃ©liorations possibles
- Migration vers PostgreSQL pour la production
- Ajout de rate limiting
- SystÃ¨me de partage de fichiers
- Recherche full-text
- Interface web plus moderne (React/Vue)
- Support des mÃ©tadonnÃ©es Ã©tendues (tags, notes)
- Versioning de fichiers
- Compression avant chiffrement

---

## ğŸš€ DÃ©marrage rapide

### Installation
```bash
pip install -r requirements.txt
```

### Lancement
```bash
python api/run_api.py
```

L'API sera accessible sur `http://127.0.0.1:8000`

### Documentation interactive
- Swagger UI : `http://127.0.0.1:8000/docs`
- ReDoc : `http://127.0.0.1:8000/redoc`

---

## ğŸ“š DÃ©tails techniques

### Configuration
- **Chunk size** : 1 MB par dÃ©faut (configurable dans `cryptolib/config.py`)
- **Token expiration** : 30 minutes
- **Algorithme** : AES-256-GCM
- **DÃ©rivation de clÃ©s** : PBKDF2 avec 100,000 itÃ©rations

### Base de donnÃ©es
- **ModÃ¨le User** : id, username, email, hashed_password, is_active, is_admin, quota_bytes, used_bytes
- **Quota par dÃ©faut** : 1 GB (1073741824 bytes)

### Structure des chunks
Chaque chunk est un fichier `.enc` contenant :
- DonnÃ©es chiffrÃ©es avec AES-256-GCM
- Nonce (IV) pour le chiffrement

### Structure des mÃ©tadonnÃ©es
Fichiers JSON contenant :
- `file_id` : Identifiant unique
- `original_name` : Nom original du fichier
- `file_size` : Taille du fichier
- `chunk_count` : Nombre de chunks
- `folder_path` : Chemin du dossier
- `upload_date` : Date d'upload
- `chunks` : Liste des chunks avec leurs chemins

---

## ğŸ” Points d'attention pour une autre IA

1. **Isolation des donnÃ©es** : Toujours utiliser `CryptoSystem(user_id=user.id)` pour garantir l'isolation
2. **Authentification** : Le token doit Ãªtre extrait depuis header OU FormData pour les uploads
3. **Chemins** : Les chemins sont relatifs Ã  `data/users/user_{id}/` pour chaque utilisateur
4. **Multithreading** : L'upload multiple utilise `ThreadPoolExecutor` pour le traitement parallÃ¨le
5. **CORS** : Actuellement configurÃ© pour accepter toutes les origines (`*`), Ã  restreindre en production
6. **Secret key JWT** : Actuellement hardcodÃ©, Ã  gÃ©nÃ©rer alÃ©atoirement en production

---

## ğŸ“ Contacts et ressources

- **Structure du projet** : Voir `README.md` Ã  la racine
- **API documentation** : Voir `api/README.md`
- **Cryptolib documentation** : Voir `cryptolib/README.md`
- **SÃ©curitÃ©** : Voir `SECURITY.md` pour les recommandations

---

**DerniÃ¨re mise Ã  jour** : Novembre 2025
**Version** : 2.0.0
**Statut** : En dÃ©veloppement actif

